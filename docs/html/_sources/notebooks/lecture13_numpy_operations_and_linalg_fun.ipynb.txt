{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 13) More NumPy Plus Linear Algebra Fundamentals\n",
    "\n",
    "Related references:\n",
    "\n",
    "- https://jakevdp.github.io/PythonDataScienceHandbook/02.04-computation-on-arrays-aggregates.html\n",
    "- https://jakevdp.github.io/PythonDataScienceHandbook/02.05-computation-on-arrays-broadcasting.html\n",
    "- [Feature Engineering for Machine Learning](https://search.lib.umich.edu/catalog/record/016260792) \n",
    "- [The Manga Guide to Linear Algebra](https://www.safaribooksonline.com/library/view/the-manga-guide/9781457166730/)\n",
    "- [Introduction to Linear Algebra by Gilbert Strang](http://math.mit.edu/~gs/linearalgebra/)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## First, let's discuss the individual project\n",
    "\n",
    "Details posted on Canvas and [Github](project_instructions.ipynb)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## The simplicity of NumPy math\n",
    "\n",
    "As we've discussed, Numpy allows us to perform math with arrays without writing loops, speeding programs and programming. \n",
    "\n",
    "As always, array sizes must be compatible. Binary operations are performed on an element-by-element basis:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "\n",
    "a = np.array([0, 1, 2])\n",
    "b = np.array([5, 5, 5])\n",
    "print(a + b)\n",
    "print(a * b)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Broadcasting\n",
    "\n",
    "We can also perform these operations with a scalar; NumPy will \"broadcast\" it to the correct size for the binary operation. In the case below, it will treat `5` as the ndarray `[5, 5, 5]` while never actually creating such an array."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(a + 5)\n",
    "print(a * 5)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "`Broadcasting` can also be done in higher dimensions:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "m = np.ones((3, 3))\n",
    "m + a"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(a)\n",
    "print(b.reshape((3, 1)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "a + b.reshape((3, 1))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A visual to describe broadcasting:\n",
    "\n",
    "![From PythonDataScienceHandbook](images/lect13_broadcasting.png)\n",
    "\n",
    "The light boxes represent the broadcasted values: again, this extra memory is not actually allocated in the course of the operation, but it can be useful conceptually to imagine that it is."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### More examples of NumPy's math knowledge"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x = [1, 2, 4, 10]\n",
    "print(\"x     =\", x)\n",
    "print(\"e^x   =\", np.exp(x))\n",
    "print(\"2^x   =\", np.exp2(x))\n",
    "print(\"3^x   =\", np.power(3, x))\n",
    "print(\"ln(x)    =\", np.log(x))\n",
    "print(\"log2(x)  =\", np.log2(x))\n",
    "print(\"log10(x) =\", np.log10(x))\n",
    "print(\"sum(x)   =\", np.sum(x))\n",
    "print(\"min(x)   =\", np.min(x))\n",
    "print(\"max(x)   =\", np.sum(x))\n",
    "print(\"mean(x)  =\", np.mean(x))\n",
    "print(\"std(x)   =\", np.std(x))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### What about math with NaNs?\n",
    "\n",
    "NaN = not a number, and you can specify NaN with np.nan."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "m = np.random.random((3, 4))\n",
    "n = np.random.random((4, 3))\n",
    "m[2, 3] = np.nan\n",
    "print(m)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "m + n.T"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "m * n.T"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's check if these other functions work with `np.nan`:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(\"m     =\", m)\n",
    "print(\"e^m   =\", np.exp(m))\n",
    "print(\"2^m   =\", np.exp2(m))\n",
    "print(\"3^m   =\", np.power(3, m))\n",
    "print(\"ln(m)    =\", np.log(m))\n",
    "print(\"log2(m)  =\", np.log2(m))\n",
    "print(\"log10(m) =\", np.log10(m))\n",
    "print(\"sum(m)   =\", np.sum(m))\n",
    "print(\"min(m)   =\", np.min(m))\n",
    "print(\"max(m)   =\", np.max(m))\n",
    "print(\"mean(m)  =\", np.mean(m))\n",
    "print(\"std(m)   =\", np.std(m))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Not all did, but there are \"NaN=safe\" versions of functions! That is, they ignore the NaNs and carry on.\n",
    "\n",
    "|Function Name      |   NaN-safe Version  | Description                                      |\n",
    "|-------------------|---------------------|--------------------------------------------------|\n",
    "| ``np.sum``        | ``np.nansum``       | Compute sum of elements                          |\n",
    "| ``np.prod``       | ``np.nanprod``      | Compute product of elements                      |\n",
    "| ``np.mean``       | ``np.nanmean``      | Compute mean of elements                         |\n",
    "| ``np.std``        | ``np.nanstd``       | Compute standard deviation                       |\n",
    "| ``np.var``        | ``np.nanvar``       | Compute variance                                 |\n",
    "| ``np.min``        | ``np.nanmin``       | Find minimum value                               |\n",
    "| ``np.max``        | ``np.nanmax``       | Find maximum value                               |\n",
    "| ``np.argmin``     | ``np.nanargmin``    | Find index of minimum value                      |\n",
    "| ``np.argmax``     | ``np.nanargmax``    | Find index of maximum value                      |\n",
    "| ``np.median``     | ``np.nanmedian``    | Compute median of elements                       |\n",
    "| ``np.percentile`` | ``np.nanpercentile``| Compute rank-based statistics of elements        |\n",
    "| ``np.any``        | N/A                 | Evaluate whether any elements are true (see note)|\n",
    "| ``np.all``        | N/A                 | Evaluate whether all elements are true (see note)|\n",
    "| N/A               | ``np.isnan``        | Test for NaN; returns a boolean array            |\n",
    "\n",
    "*Note*:  NaN, positive infinity and negative infinity evaluate to True because these are not equal to zero."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(\"sum(m)   =\", np.nansum(m))\n",
    "print(\"min(m)   =\", np.nanmin(m))\n",
    "print(\"max(m)   =\", np.nanmax(m))\n",
    "print(\"mean(m)  =\", np.nanmean(m))\n",
    "print(\"std(m)   =\", np.nanstd(m))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "These are a few examples, but just ask the Internet if there is anything you need and you'll get an answer, even if that is to use `scipy.special` as we had to for `erfc`. Let's focus on a particular kind of math NumPy knows well: linear algebra."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Linear algebra"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Overview\n",
    "\n",
    "![What is linear algebra](images/lect13_linear-alg.png)\n",
    "This and other comics from [The Manga Guide to Linear Algebra](https://www.safaribooksonline.com/library/view/the-manga-guide/9781457166730/)\n",
    "\n",
    "Importantly, they are great for solving linear equations, especially those with the same number unknowns and independent equations. They are great for turning problems into forms that are easily solved by computers!"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![What is linear algebra](images/lect13_linear-alg-overview.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Fundamentals\n",
    "\n",
    "#### Inverse Functions\n",
    "\n",
    "![Functions](images/lect13_onto-one2one.png)\n",
    "![Functions](images/lect13_inverse.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Linear Transformations\n",
    "\n",
    "Let $x_i$ and $x_j$ be two arbitrary elements of the set $X$, $c$ be any real number, and $f$ be a function from $X$ to $Y$. $f$ is called a *linear transformation* from $X$ to $Y$ if is satisfies both:\n",
    "\n",
    "1. $f(x_i) + f(x_j) = f(x_i + x_j)$\n",
    "1. $cf(x_i) = f(cx_i)$\n",
    "\n",
    "![Functions](images/lect13_linear-trans.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Permutations\n",
    "\n",
    "Choosing three from n items in a certain order creates a permutation of the chosen items. The number of possible permutations of k objects chosen among n objects is written as: \n",
    "$ _nP_k $\n",
    "The number of ways k objects can be chosen among n possible ones is equal to:\n",
    "$$ _nP_k = \\frac{n!}{(n-k)!} $$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Combinations\n",
    "\n",
    "Choosing k among n items without considering the order in which they are chosen is called a combination. The number of different ways this can be done is written by using the binomial coefficient notation:\n",
    "$ {n\\choose k} $ or $_nC_r$\n",
    "which is read \"n choose k.\"\n",
    "\n",
    "$$ {n\\choose k} = \\frac{n!}{k!(n-k)!} = \\frac{_nP_k}{k!} $$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "When the order *doesn't* matter, it is a Combination.\n",
    "\n",
    "When the order *does* matter it is a Permutation.\n",
    "![Basics](images/lect13_permutation.png)\n",
    "A Permutation is an ordered Combination."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Matrices\n",
    "\n",
    "![Matrices](images/lect13_matrix.png)\n",
    "![Matrices](images/lect13_matrix1.png)\n",
    "![Matrices](images/lect13_matrix2.png)\n",
    "![Matrices](images/lect13_matrix3.png)\n",
    "![Matrices](images/lect13_matrix4.png)\n",
    "![Matrices](images/lect13_matrix5.png)\n",
    "![Matrices](images/lect13_matrix6.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Matrix Addition\n",
    "\n",
    "![Matrices](images/lect13_matrix7.png)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "a = np.array([[10, 10]])\n",
    "b = np.array([[3, 6]])\n",
    "print(a, b)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(a - b)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Scalar Multiplication\n",
    "\n",
    "![Matrices](images/lect13_matrix8.png)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = np.arange(1, 7).reshape((3, 2))\n",
    "print(c)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(10 * c)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Matrix Multiplication\n",
    "\n",
    "![Matrices](images/lect13_matrix9.png)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "d = np.array([[8, -3], [2, 1]])\n",
    "e = np.array([[3, 1], [1, 2]])\n",
    "print(d)\n",
    "print(e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(d * e)\n",
    "print(np.multiply(e, d))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.matmul(d, e)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.matmul(e, d)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Matrices](images/lect13_matrix10.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Special Matrices\n",
    "\n",
    "![Matrices](images/lect13_matrix11.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Matrices](images/lect13_matrix12.png)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "f = np.array([[2, 0], [0, 3]])\n",
    "print(f)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.linalg.matrix_power(f, 3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Matrices](images/lect13_matrix13.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### What is the identity matrix and why is it called that?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "eye = np.eye(2, dtype=int)\n",
    "print(d)\n",
    "print(eye)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.matmul(d, eye)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.matmul(eye, d)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Matrices](images/lect13_matrix14.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If the product of two square matrices is an identity matrix, then the two factor matrices are inverses of each other. This means that \n",
    "$ \\left( \\begin{array}{ccc}\n",
    "x_{11} & x_{12} \\\\\n",
    "x_{21} & x_{22} \\end{array} \\right) $ is an inverse matrix to \n",
    "$ \\left( \\begin{array}{ccc}\n",
    "1 & 2 \\\\\n",
    "3 & 4 \\end{array} \\right) $  if\n",
    "\n",
    "$$ \\left( \\begin{array}{ccc}\n",
    "1 & 2 \\\\\n",
    "3 & 4 \\end{array} \\right)\n",
    "\\left( \\begin{array}{ccc}\n",
    "x_{11} & x_{12} \\\\\n",
    "x_{21} & x_{22} \\end{array} \\right)\n",
    "= \\left( \\begin{array}{ccc}\n",
    "1 & 0 \\\\\n",
    "0 & 1 \\end{array} \\right) $$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Matrices](images/lect13_matrix15.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Matrices](images/lect13_matrix16.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Matrices](images/lect13_matrix17.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now, using Gaussian elimination (e.g. the sweeping method) find, the inverse matrix of \n",
    "$ \\left( \\begin{array}{ccc}\n",
    "3 & 1 \\\\\n",
    "1 & 2 \\end{array} \\right) $"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "g = np.array([[3, 1], [1, 2]])\n",
    "h = np.linalg.inv(g)\n",
    "print(h)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# checking our work\n",
    "np.matmul(g, h)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.matmul(h, g)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Matrices](images/lect13_matrix18.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Matrices](images/lect13_matrix19.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Matrices](images/lect13_matrix20.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Calculating determinants\n",
    "\n",
    "From: https://www.mathsisfun.com/algebra/matrix-determinant.html\n",
    "![Matrices](images/lect13_matrix21.png)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "k = np.array([[4, 6], [3, 8]])\n",
    "np.linalg.det(k)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Matrices](images/lect13_matrix22.png)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "m = np.array([[6, 1, 1], [4, -2, 5], [2, 8, 7]])\n",
    "print(m)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.linalg.det(m)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Matrices](images/lect13_matrix23.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Next up: Vectors!"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
